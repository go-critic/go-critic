exit status 1
./main.go:14:7: appendAssign: append result not assigned to the same slice
./main.go:19:2: appendCombine: can combine chain of 2 appends into one
./main.go:268:6: argOrder: "$" and s arguments order looks reversed
./main.go:24:2: assignOp: replace `x = x + 2` with `x += 2`
./main.go:276:35: badCall: suspicious arg 0, probably meant -1
./main.go:246:6: badCond: `x < 100 && x > 200` condition is always false
./main.go:28:9: boolExprSimplify: can simplify `!(x == y+1)` to `x != y+1`
./main.go:31:20: builtinShadow: shadowing of predeclared identifier: new
./main.go:33:16: captLocal: `THIS' should not be capitalized
./main.go:38:2: caseOrder: case int must go before the interface{} case
./main.go:242:2: commentFormatting: put a space between `//` and comment text
./main.go:43:2: commentedOutCode: may want to remove commented-out code
./main.go:50:2: defaultCaseOrder: consider to make `default` case as first or as last case
./main.go:280:2: deferUnlambda: can rewrite as `defer add1(1)`
./main.go:59:1: deprecatedComment: the proper format is `Deprecated: <text>`
./main.go:63:1: docStub: silencing go lint doc-comment warnings is unadvised
./main.go:66:2: dupArg: suspicious duplicated args in copy(xs, xs)
./main.go:70:2: dupBranchBody: both branches in if statement have same body
./main.go:81:7: dupCase: 'case x == 0' is duplicated
./main.go:86:9: dupSubExpr: suspicious identical LHS and RHS for `<` operator
./main.go:91:9: elseif: can replace 'else {if cond {}}' with 'else if cond {}'
./main.go:102:3: emptyFallthrough: replace empty case containing only fallthrough with expression list
./main.go:100:3: emptyFallthrough: replace empty case containing only fallthrough with expression list
./main.go:255:2: exitAfterDefer: log.Fatal will exit, and `defer func(){...}(...)` will not run
./main.go:111:6: flagDeref: immediate deref in *flag.String("str", "", "usage") is most likely an error; consider using flag.StringVar
./main.go:238:6: flagName: flag name " foo " contains whitespace
./main.go:114:16: hugeParam: x is heavy (80000 bytes); consider passing it by pointer
./main.go:142:20: hugeParam: xs is heavy (8000 bytes); consider passing it by pointer
./main.go:117:2: ifElseChain: rewrite if-else to switch statement
./main.go:123:19: importShadow: shadow of imported package 'flag'
./main.go:126:6: indexAlloc: consider replacing strings.Index(string(s), sub) with bytes.Index(s, []byte(sub))
./main.go:130:6: methodExprCall: consider to change `point.String` to `p.String`
./main.go:272:6: newDeref: replace `*new(string)` with `""`
./main.go:135:3: nilValReturn: returned expr is always nil; replace x with nil
./main.go:234:9: offBy1: index expr always panics; maybe you wanted xs[len(xs)-1]?
./main.go:140:1: paramTypeCombine: func(x int, y int) could be replaced with func(x, y int)
./main.go:143:2: rangeExprCopy: copy of xs (8000 bytes) can be avoided with &xs
./main.go:149:2: rangeValCopy: each iteration copies 8000 bytes (consider pointers or indexing)
./main.go:155:11: regexpMust: for const patterns like `this`, use regexp.MustCompile
./main.go:160:2: singleCaseSwitch: should rewrite switch statement to if statement
./main.go:168:9: sloppyLen: len(xs) < 0 is always false
./main.go:173:5: sloppyReassign: re-assignment to `err` can be replaced with `err := (point{})`
./main.go:180:2: switchTrue: replace 'switch true {}' with 'switch {}'
./main.go:260:2: typeAssertChain: rewrite if-else to type switch statement
./main.go:189:2: typeSwitchVar: 2 cases can benefit from type switch with assignment
./main.go:200:8: typeUnparen: could simplify (func()) to func()
./main.go:204:9: underef: could simplify (*xs)[2] to xs[2]
./main.go:208:1: unlabelStmt: label loop is redundant
./main.go:216:11: unlambda: replace `func(x int) int { return add1(x) }` with `add1`
./main.go:219:39: unslice: could simplify xs[:] to xs
./main.go:250:6: weakCond: suspicious `xs == nil || xs[0] == 0`; nil check may not be enough, check for len
